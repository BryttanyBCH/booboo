Thu Jul 15 03:41:37 MSD 2010  voker57@gmail.com
  * Merged XtractLazy to Xtract
  
  Added -l (--lazy) option to Xtract, rendering XtractLazy obsolete
diff -rN -u old-HaXml/src/tools/Xtract.hs new-HaXml/src/tools/Xtract.hs
--- old-HaXml/src/tools/Xtract.hs	2010-09-28 05:59:45.000000000 +0400
+++ new-HaXml/src/tools/Xtract.hs	2010-09-28 05:59:50.000000000 +0400
@@ -10,24 +10,26 @@
 import System.Environment     (getArgs)
 import System.Console.GetOpt
 
-import Text.XML.HaXml               (version)
+import Text.XML.HaXml                          (version)
 import Text.XML.HaXml.Types
-import Text.XML.HaXml.Posn          (posInNewCxt)
-import Text.XML.HaXml.Parse         (xmlParse)
-import Text.XML.HaXml.Html.Parse    (htmlParse)
-import Text.XML.HaXml.Xtract.Parse  (xtract)
-import Text.PrettyPrint.HughesPJ    (Doc,render, vcat, hcat, empty)
-import Text.XML.HaXml.Pretty        (content)
-import Text.XML.HaXml.Html.Generate (htmlprint)
-import Text.XML.HaXml.Escape        (xmlEscapeContent,stdXmlEscaper)
-import Text.XML.HaXml.Util          (docContent)
+import Text.XML.HaXml.Posn                     (posInNewCxt)
+import qualified Text.XML.HaXml.Parse          (xmlParse)
+import qualified Text.XML.HaXml.Html.Parse     (htmlParse)
+import Text.XML.HaXml.Xtract.Parse             (xtract)
+import qualified Text.XML.HaXml.ParseLazy      (xmlParse)
+import qualified Text.XML.HaXml.Html.ParseLazy (htmlParse)
+import Text.PrettyPrint.HughesPJ               (Doc,render, vcat, hcat, empty)
+import Text.XML.HaXml.Pretty                   (content)
+import Text.XML.HaXml.Html.Generate            (htmlprint)
+import Text.XML.HaXml.Escape                   (xmlEscapeContent,stdXmlEscaper)
+import Text.XML.HaXml.Util                     (docContent)
 
 escape :: [Content i] -> [Content i]
 escape = xmlEscapeContent stdXmlEscaper
 
-data Opts = Opts {doEscaping :: Bool, forceHtml :: Bool, printHelp :: Bool, printVersion :: Bool}
+data Opts = Opts {doEscaping :: Bool, forceHtml :: Bool, printHelp :: Bool, printVersion :: Bool, beLazy :: Bool}
 
-defaultOptions = Opts {doEscaping = True, forceHtml = False, printHelp = False, printVersion = False}
+defaultOptions = Opts {doEscaping = True, forceHtml = False, printHelp = False, printVersion = False, beLazy = False}
 
 options :: [OptDescr (Opts -> Opts)]
 options = [
@@ -38,7 +40,9 @@
     Option [] ["help"]
         (NoArg (\o -> o {printHelp = True})) "Displays this help",
     Option [] ["version"]
-        (NoArg (\o -> o {printVersion = True})) "Prints version"
+        (NoArg (\o -> o {printVersion = True})) "Prints version",
+    Option ['l'] ["lazy"]
+        (NoArg (\o -> o {beLazy = True})) "Parse lazily"
     ]
 
 main :: IO ()
@@ -55,6 +59,10 @@
   when (length args < 1) $ do
       putStrLn $ usageInfo "Usage: Xtract [options] <pattern> [xmlfile ...]" options
       exitWith (ExitFailure 1)
+  let (xmlParse, htmlParse) = if beLazy opts then 
+        (Text.XML.HaXml.ParseLazy.xmlParse, Text.XML.HaXml.Html.ParseLazy.htmlParse) 
+        else 
+        (Text.XML.HaXml.Parse.xmlParse, Text.XML.HaXml.Html.Parse.htmlParse)
   let (pattern,files,esc) =
           (head args,tail args,if doEscaping opts then escape .(:[]) else (:[]))
 --      findcontents =
diff -rN -u old-HaXml/src/tools/XtractLazy.hs new-HaXml/src/tools/XtractLazy.hs
--- old-HaXml/src/tools/XtractLazy.hs	2010-09-28 05:59:45.000000000 +0400
+++ new-HaXml/src/tools/XtractLazy.hs	1970-01-01 03:00:00.000000000 +0300
@@ -1,73 +0,0 @@
-------------------------------------------------------------
--- The Xtract tool - an XML-grep.
------------------------------------------------------------- 
-module Main where
-import System (getArgs, exitWith, ExitCode(..))
-import IO
-import Char   (toLower)
-import List   (isSuffixOf)
-import Monad  (when)
-
-import Text.XML.HaXml               (version)
-import Text.XML.HaXml.Types
-import Text.XML.HaXml.Posn          (posInNewCxt,Posn)
-import Text.XML.HaXml.ParseLazy     (xmlParse)
-import Text.XML.HaXml.Html.ParseLazy(htmlParse)
-import Text.XML.HaXml.Xtract.Parse  (xtract)
-import Text.PrettyPrint.HughesPJ    (Doc,render, vcat, hcat, empty)
-import Text.XML.HaXml.Pretty        (content)
-import Text.XML.HaXml.Html.Generate (htmlprint)
-import Text.XML.HaXml.Escape        (xmlEscapeContent,stdXmlEscaper)
-
-escape :: [Content i] -> [Content i]
-escape = xmlEscapeContent stdXmlEscaper
-
-main :: IO ()
-main = do
-  args <- getArgs
-  when ("--version" `elem` args) $ do
-      putStrLn $ "part of HaXml-"++version
-      exitWith ExitSuccess
-  when ("--help" `elem` args) $ do
-      putStrLn $ "See http://haskell.org/HaXml"
-      exitWith ExitSuccess
-
-  when (length args < 1) $ do
-      putStrLn "Usage: Xtract [-n] <pattern> [xmlfile ...]"
-      exitWith (ExitFailure 1)
-
-  let (pattern,files,esc) =
-          case args of ("-n":pat:files) -> (pat,files, (:[]))
-                       (pat:"-n":files) -> (pat,files, (:[]))
-                       (pat:files)      -> (pat,files, escape.(:[]))
---      findcontents =
---        if null files then (getContents >>= \x-> return [xmlParse "<stdin>"x])
---        else mapM (\x-> do c <- (if x=="-" then getContents else readFile x)
---                           return ((if isHTML x
---                                    then htmlParse x else xmlParse x) c))
---                  files
---  findcontents >>= \cs->
---  ( hPutStrLn stdout . render . vcat
---  . map (vcat . map content . selection . getElem)) cs
-  mapM_ (\x->   do c <- (if x=="-" then getContents else readFile x)
-                   ( if isHTML x then
-                          hPutStrLn stdout . render . htmlprint
-                          . xtract (map toLower) pattern
-                          . getElem x . htmlParse x
-                     else hPutStrLn stdout . render . vcat . map (format . esc)
-                          . xtract id pattern
-                          . getElem x . xmlParse x) c
-                   hFlush stdout)
-          files
-
-getElem :: String -> Document Posn -> Content Posn
-getElem x (Document _ _ e _) = CElem e (posInNewCxt x Nothing)
-
-isHTML :: [Char] -> Bool
-isHTML x = ".html" `isSuffixOf` x  ||  ".htm"  `isSuffixOf` x
-
-format :: [Content i] -> Doc
-format [] = empty
-format cs@(CString _ _ _:_) = hcat . map content $ cs
-format cs@(CRef _ _:_)      = hcat . map content $ cs
-format cs                   = vcat . map content $ cs
