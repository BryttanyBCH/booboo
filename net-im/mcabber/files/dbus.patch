diff -ruN mcabber-old/src/dbusglue.c mcabber/src/dbusglue.c
--- mcabber-old/src/dbusglue.c	1970-01-01 03:00:00.000000000 +0300
+++ mcabber/src/dbusglue.c	2009-05-20 12:59:01.324599309 +0400
@@ -0,0 +1,177 @@
+/*
+ * DBus glue for MCabber function process_command
+ *
+ * Authored by Akarsh Simha <akarshsimha@gmail.com>
+ * 13th Apr 2008
+ *
+ * (c) Akarsh Simha 2008
+ *
+ * Licensed under GPL.
+ * This code comes with absolutely no warranty.
+ *
+ */
+
+#include <dbus/dbus.h>
+#include <glib.h>
+
+#include "commands.h"
+#include "screen.h"
+#include "dbusglue.h"
+
+DBusConnection *conn = NULL;
+DBusError err;
+
+gchar dbusglue_get_connection() {
+
+  gchar ret;
+
+  dbus_error_init(&err);
+  conn = dbus_bus_get(DBUS_BUS_SESSION, &err);
+
+  if(!conn) {
+    scr_LogPrint(LPRINT_NORMAL, "Could not get connection to DBus Session Bus. DBus support disabled.");
+    return 0;
+  }
+
+  ret = dbus_bus_request_name(conn, "org.freedesktop.mcabber", DBUS_NAME_FLAG_REPLACE_EXISTING, &err);
+
+  if(dbus_error_is_set(&err)) {
+    scr_LogPrint(LPRINT_NORMAL, "DBus Name Error:");
+    scr_LogPrint(LPRINT_NORMAL, err.message);
+  }
+  
+  if(ret != DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER)
+    scr_LogPrint(LPRINT_NORMAL, "DBus Name Error: Not the primary owner of name requested!");   
+
+  return 1;
+  
+}
+
+void dbusglue_check_call() {
+
+  DBusMessage *msg;
+
+  if(!conn)
+    return; // Ignore
+
+  dbus_connection_read_write(conn, 0);
+  msg = dbus_connection_pop_message(conn);
+
+  if(msg == NULL)
+    return;
+
+  if(dbus_message_is_method_call(msg, "org.freedesktop.mcabber", "process_command")) {
+    dbusglue_process_command(msg);
+  }
+
+  dbus_message_unref(msg);
+}
+
+void dbusglue_process_command(DBusMessage *msg) {
+
+  DBusMessage *reply;
+  DBusMessageIter args;
+  dbus_uint32_t serial = 0;
+  int ret;
+  int errval = 0;
+  char *error;
+  char *str;
+  char *line;
+
+  if(!dbus_message_iter_init(msg, &args) || dbus_message_iter_get_arg_type(&args) != DBUS_TYPE_STRING) {
+    ret = 0;
+    errval = 1;
+    error = g_strdup("process_command requires a string argument that contains the command line to process");
+  }
+  else {
+    dbus_message_iter_get_basic(&args, &line);
+
+    str = g_strdup_printf("Received command through DBus: %s", line);
+    scr_LogPrint(LPRINT_NORMAL, str);
+    g_free(str);
+
+    ret = process_command(line, 1);
+  }
+
+    reply = dbus_message_new_method_return(msg);
+
+    dbus_message_iter_init_append(reply, &args);
+    if(!dbus_message_iter_append_basic(&args, DBUS_TYPE_UINT16, &ret)) {
+      dbus_message_unref(reply);
+      scr_LogPrint(LPRINT_NORMAL, "DBus Error: Could not respond to RPC!");   
+      return;
+    }
+
+    if(errval) {
+      dbus_message_iter_append_basic(&args, DBUS_TYPE_STRING, &error);
+      g_free(error);
+    }
+  
+  dbus_connection_send(conn, reply, &serial);
+  dbus_connection_flush(conn);
+
+}
+
+/*
+void dbusglue_say_to(DBusMessage *msg) {
+
+  DBusMessage *reply;
+  DBusMessageIter args;
+  dbus_uint32_t serial = 0;
+  int ret;
+  int errval = 0;
+  char *error;
+  char *str;
+  char *arg1, *arg2;
+
+  if(!dbus_message_iter_init(msg, &args) || dbus_message_iter_get_arg_type (&args) != DBUS_TYPE_STRING) {
+    ret = 0;
+    errval = 1;
+    error = g_strdup("say_to requires atleast one string argument");
+  }
+  else {
+
+    if(dbus_message_iter_get_arg_type (&args) == DBUS_TYPE_STRING)
+      dbus_message_iter_get_basic(&args, &arg1);
+    else
+      arg1 = NULL;
+    if(dbus_message_iter_get_arg_type (&args) == DBUS_TYPE_STRING)
+      dbus_message_iter_get_basic(&args, &arg2);
+    else
+      arg2 = NULL;
+
+    str = g_strdup_printf("Received message to %s through DBus", ((arg2 == NULL)?("current JID"):arg2));
+    scr_LogPrint(LPRINT_NORMAL, str);
+    g_free(str);
+
+    if(arg2 == NULL) {
+      do_say(arg1);
+    }
+    else {
+      str = g_strdup_printf("%s %s", arg1, arg2);
+      do_say_to(str);
+      g_free(str);
+    }
+
+  }
+
+    reply = dbus_message_new_method_return(msg);
+
+    dbus_message_iter_init_append(reply, &args);
+    if(!dbus_message_iter_append_basic(&args, DBUS_TYPE_UINT16, &ret)) {
+      dbus_message_unref(reply);
+      scr_LogPrint(LPRINT_NORMAL, "DBus Error: Could not respond to RPC!");   
+      return;
+    }
+
+    if(errval) {
+      dbus_message_iter_append_basic(&args, DBUS_TYPE_STRING, &error);
+      g_free(error);
+    }
+  
+  dbus_connection_send(conn, reply, &serial);
+  dbus_connection_flush(conn);
+
+}
+*/
+
diff -ruN mcabber-old/src/dbusglue.h mcabber/src/dbusglue.h
--- mcabber-old/src/dbusglue.h	1970-01-01 03:00:00.000000000 +0300
+++ mcabber/src/dbusglue.h	2009-05-20 12:59:01.324599309 +0400
@@ -0,0 +1,48 @@
+/*
+ * DBus glue for MCabber function process_command
+ *
+ * Authored by Akarsh Simha <akarshsimha@gmail.com>
+ * 13th Apr 2008
+ *
+ * (c) Akarsh Simha 2008
+ *
+ * Licensed under GPL.
+ * This code comes with absolutely no warranty.
+ *
+ */
+
+#include <dbus/dbus.h>
+
+#ifndef __DBUSGLUE_H__
+#define __DBUSGLUE_H__
+
+// extern DBusError err;
+// extern DBusConnection *conn;
+
+/**
+ *
+ * @short  Gets a connection to the DBus Session Bus
+ *
+ * @return non-zero on success, 0 on failure
+ *
+ */
+
+inline gchar dbusglue_get_connection();
+
+/**
+ *
+ * @short Checks for DBus Method Calls
+ *
+ */
+
+inline void dbusglue_check_call();
+
+/**
+ *
+ * @short  Handles the DBus method call for process_command
+ *
+ */
+
+inline void dbusglue_process_command(DBusMessage *msg);
+
+#endif
diff -ruN mcabber-old/src/filter.c mcabber/src/filter.c
--- mcabber-old/src/filter.c	1970-01-01 03:00:00.000000000 +0300
+++ mcabber/src/filter.c	2009-05-20 12:59:01.324599309 +0400
@@ -0,0 +1,110 @@
+#include <glib.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <string.h>
+
+#include "filter.h"
+#include "screen.h"
+
+char *filter_message(const char *bjid, const char *resname, time_t timestamp, const char *msg, const char *type) {
+
+  FILE *f;
+  char *home;
+  char *tmp_buf;
+  char *ret_buf;
+  char *fname;
+  char *msg_esc;
+  char *j;
+  char *i;
+  unsigned int nq;
+
+  long unsigned flen;
+
+  home = NULL;
+  home = getenv("HOME");
+
+  if(!home) {
+    scr_LogPrint(LPRINT_LOG, "Could not find home directory");
+    return NULL;
+  }
+
+  fname = g_strdup_printf("%s/.mcabber/filter", home);
+  if(fname == NULL) {
+    scr_LogPrint(LPRINT_LOG, "Could not allocate memory for filename");
+    return NULL;
+  }
+
+  f = fopen(fname, "r");
+
+  if(f == NULL) {
+    scr_LogPrint(LPRINT_LOG, "Could not open ~/.mcabber/fitler - no filter will be applied!");
+    return NULL;
+  }
+
+  fclose(f);
+
+  // Escape any quotes in msg
+
+  for(i = msg, nq = 0; *i != '\0'; i++)
+    if(*i == '\'' || *i == '\"' || *i == '$' || *i == '\\')
+      ++nq;
+
+  if(nq != 0) {
+    msg_esc = (char *)malloc((strlen(msg) + nq)*sizeof(char) + 1);
+
+    if(msg_esc == NULL) {
+      scr_LogPrint(LPRINT_LOG, "Could not allocate memory for escaped string - will not filter message");
+      return NULL;
+    }
+
+    for(i = msg, j = msg_esc; *i != '\0'; i++, j++) {
+      if(*i == '\'' || *i == '\"' || *i == '$' || *i == '\\') {
+	*j = '\\';
+	j++;
+      }
+      *j = *i;
+    }
+
+    *j='\0';
+
+  }
+  else
+    msg_esc = msg;
+
+  tmp_buf = g_strdup_printf("%s \'%s\' \'%s\' \"%s\" \'%s\' > /tmp/mcabber_filter 2> /dev/null", fname, bjid, resname, msg_esc, type);
+  system(tmp_buf);
+
+  g_free(tmp_buf);
+  g_free(fname);
+  if(msg_esc != msg)
+    free(msg_esc);
+
+  if((f = fopen("/tmp/mcabber_filter", "r")) != NULL) {
+
+    fseek(f, 0, SEEK_END);
+    flen = ftell(f);
+    rewind(f);
+
+    tmp_buf = (char *)malloc((flen + 1)*sizeof(char));
+
+    if(tmp_buf == NULL) {
+      fclose(f);
+      return NULL;
+    }
+
+    fread (tmp_buf, 1, flen, f);
+    tmp_buf[flen] = '\0';
+
+    fclose(f);
+    ret_buf = g_strdup(tmp_buf);
+    free(tmp_buf);
+
+    return ret_buf;
+  }
+  else {
+    scr_LogPrint(LPRINT_LOG, "Filter: Could not find file /tmp/mcabber_filter");
+  }
+
+  return NULL;
+}
diff -ruN mcabber-old/src/filter.h mcabber/src/filter.h
--- mcabber-old/src/filter.h	1970-01-01 03:00:00.000000000 +0300
+++ mcabber/src/filter.h	2009-05-20 12:59:01.324599309 +0400
@@ -0,0 +1,9 @@
+#ifndef __FILTER_H__
+#define __FILTER_H__ 1
+
+#include <stdlib.h>
+#include <stdio.h>
+
+inline char *filter_message(const char *bjid, const char *resname, time_t timestamp, const char *msg, const char *type);
+
+#endif
